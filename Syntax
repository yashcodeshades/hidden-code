What is active record Query interface?
If youre used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in rails. Active records insulates you from the need to use SQL in most cases.
Active record will perform queries on the database for you and is compatible with most database system, including mySQL mariaDB, PostgreSQL, and SQlite.
Regardless of which database system you're using, the Active mettho format  will always be the same.
Code esxample throught this guide will refer to one of the more of the following models:
All of the following models use id as the primary key, unless specified otherwise 
class Author < ApplicationRecord
has_many :books, -> { order(year_publish: :desc) }
end

class Book < ApplicationRecord
belongs_to : supplier
belongs_to :author
has_many :reviews
has_and_belongs_to_many :orders, join_table: 'books_orders'
scope :in_print, -> { where(out_of_print: false) } 
scope :out_of_print, -> { where(out_of_print: true) }
scope :old, -> { where('year_published < ?', 50.years.ago ) }
scope :out_of_print_and_expensive, -> {
out_of_print.where('price > 500") }
scope :cost_more_than, ->(amount) {where('price > ?', amount) }
end

class Customer <ApplicationRecord
has_many :orders
has_many:reviews
end

class order <ApplicationRecord
belongs_to :customer
has_and_belongs_to_many :books, join_table:
'books_orders'
enum :status, [:shipped, :being_packed, :complete, :cancelled]
scope :created_before, ->(time) {where('created_at <?', time) }
end
 
 
vlass Review < ApplicationRecord
belongs_to :customer
belongs_to :book

enum :state, [:not_reviewed, :published, :hidden]
end

class Supplier <ApplicationRecord
has_many :books
has_many :authors, through: :books
end


Retrieving data from the database
To retrieve data from the database, ActivveRecord provides several finder methods. Each finder method allows you to pass arguments into it to perform certain queeries on your database without wwwritting raw SQL.
The method are:
annotate
find
create with 
distinct
aeager_load
extending
extract_associated
from 
group 
having
includes
joins
left_outer_joins
limit
lock
none
offset
optimizer_hints
order
preload
readonly
reference
reorder
reselect
reverse_order
select
where

Finder methods that return a collection, such as where and group, return an instance of ActiveRecord::Relation. Methods that find a single entity, such as find and first, return a single instance of the model.
The Primary operation of Model.find(options) can be summarized as:
- Convert the supplied options to an equivalent SQL query.
- Fire the SQL query and retrieve the corresponding results from the database.
Instantiate the equivalent ruby object of the appropriate model for every resulting row.
Run after_find and then after_insitialize callbacks, if any.

Retrieving a single Object
Active Record providfes several different ways of retrieving a single object.

Find 
Using the find method, you can retrieve the object corresponding to the specified perimary key that matches any supplied option, for example:
#find the customer with primary key (id) 10
irb> customer = Customer.find(10)
=>Customer id: 10, first_name: "Ryan">

The SQL equivalent to the above is :
SELECT * FROM customers WHERE (customers.id = 10) LIMT 1
The find method will raise an ActiveRecord: :RecordNot Found exception if no matching record is found.
You can also use this method to query for multiple objects. Call the find method
and pass in an array of primary keys. For example:
#find the customers withj primary key 1 and 10
irb> customers = Customer.find([1,10]) # OR 
Customer.find(1,10)
=> [#<Customer id: 1. first_name: "Lifo">, #<Customer id: 10, first_name: "Ryan">

The SQL equivalent of the above is:
SELECT *FROM cudstomers WHERE (customers.id IN (1,10))
the find method will raise an ActiveRecord::RecordNotFound
exception unless a matching record is found for all the supplied Primary keys.

take 
the take method retrieves a reccord without any implicit ordering. for example:
irb> Customer = Customer.take
=> #<customer id: 1, first_name: "Lifo">

The SQL equivalent of the above is:

SLECt * FROM customers LIMIT 1
The take method returns nil if no record is found and no exception will be raised 
You can pass in a numerical argument to the taks method to return up that number of results, for example 
irb> customers = Customer.take(2)
=> [#Customer id: 1, first_name : "Lifo">, #,customere 
id: 220, first_name: "Sara">]

The SQL equivalent of the above is :
SELECT * FROM customer LIMIT 2
The take! method behaves exactly like, except that it will raise Activerecord::RecordNotFound if no matching is found
The retrieved record may vary depending on the database engine.
first
The first method finds the first record ordered by primary key (default). for example
irb> customer = Customer.first
=> #Customer id: 1, first_name: "Lifo">

The SQL equivalent of the above is: 
SELECT * FROM customer ORDER BY customer.id ASC LIMIT 1

the first method returns nil if no matching record is found and no exception willl be raised If your default scope contains an order method, first will return the first record according to the ordering.
You can pass in a numerical argument to the first method to return up to theat number of results. For example
irb> Customers = Customers = Customer.first(3)
=> [#<customer id: 1, first_name: "Lifo"> #<customer id: 2, first_name: "Fifo">, #<customer id:3,
first_name : "Fifo">]
The SQL equivalent of the above is:
SELECT * FROM customers order BY customers.id ASC LIMIT 3
On a collection that is ordering using order.first will return the first record order by the specified attribute for order.
irb> customer = Customer,order(:first_name).first
=> #<customer id : 2, first_name: "Fifo">
The SQL equivalent of the above is: 
SELECT * FROM customers ORDER BY customers.first_name ASC LIMIT 1

The first! method behaves exactly like fist, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.
example 
irb> customer = Customer.lastt 
=> #Customer id : 221, first_name : "Russel">
The SQL equivalent of the above is: 
SELECT * FROM cusotmers ORDER BY customers.id DESC LIMIT  1
The last method returns nil if no matching record is found and no exception will be raised.

if your default score contains an ordfer method, last will return the last record according to this ordering.
You can pass in a numerical argument to the last method to return up to that number of results. for example

irb> customer = Customer.last(3)
=> [#<customer id: 219, first_name: "James">, #<Custoemr id: 220, first_name: "Sara">, #<customer id: 221,
first_name: "russsel">]
The SQL equivalent of the above is:
SELECT * FROM customers ORDER BY customers.id DESC LIMIT 3
On a collection that is ordered using order, last will return the last record ordfered by the specified attributes for order .
irb> customer = Cusotmer.order(:first_name).last 
=> #<customer id: 220, first_name: "Sara">

The SQL equivalent of the above is:
SELECT * FROM cusotmers ORDER BY customers.first_name DESC LIMIT 1
The last! method behaves exactly like last, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.
find_by
The find_by method finds the first record matching some conditions. For example:
irb> Cusotmer.find_by first_name: "Lifo'
=> #<Customer id: 1, first_name: :"Lifo">

irb> Customer.find_by first_name: 'Jon'
=>nil
It is equivalent to writing:
Cusotmer.where(first_name: 'Lifo').take
the SQL equivalent of the above is:
SELECT * From customer WHERE (customer.first_name = 'Lifo') LIMiT 1

note that there is no ORDER BY in the SQL. If your find_by conditions can match multiple records, you should apply an order to deterministic result.

The find by! method bbehaved exactly like find_by except that it will raise ActiveRecord::RecordNotFound if no matching is found, forr example:
irb> Customer.find_by! first_name: 'does not exist'
ActiveRecord::RecordNotFound
this is equivalent to writting
Customer.where(first_name: 'does bot exist').take!
Retrieving Multiple Objects in Batches
We often need toiterate oever a large set of records, as when we send a newsletter to a lare set of customers, or whenwe export data.
This is appear strightforward:
#this may consume too much memory if the table is big. 
Customer.all.each do |customer|
NewsMailer.weekly(customer).deliver_now
end
By this approach becomes incereasingly impractical aas the table size increases, since Customer.all.each instruct Active Record to fetch the entire table in a single pass, builsd a model object per row , and then keep the entire arrray of model objects in memory, indeed, if we have a large number of records, the entire collection may exceed the amount of memory availabl.
Rails provided two methods that address this problem by dividing records into memory- friendly batches for processing the First method find_each retrieves a batch of records and then yields each record to the block individually as a model. The entire batch to the block as an array of models.
The find_each and find_in_batchs methods are intended for use in the batch processing of a large number of records that wouldn't fit in the memory of all at once If you just need to loop over a thousand records the regular find methods are preferred option.
find_each 
thefind_each
The find_each method retrieves records in batches and then yields each one to the block in the following example. find_each retrieves customers in batches of 1000 and yieldss them to block one by one
Customer.find_each do |customer|
Newsmailer.weekly(sustomer).deliver_now
end
this process is repeated, fetching more batches as needed, untill all of the records have been processed.
find_each works on model classes as seen above and also on relations:
Cusotmer.where (weekly_subscriber: true).find_each do 
|customer|
NewsMailer.weekly(suctomer).deliver_now
end
as l;ong as they have no ordering, since the method needs to force an order internally to iterate.
If an order is present in the receiver the behaviour depends on the flag config.active_record.error_on_ifnored _order If true, ArgumentError is raised otherwise the orderis ignored and a warning issued, which is the default this can be overriden with the option :error_on_ignore
explain below
Option for find_each
:batch_size
The :batch_size option allows you to specify the number of recordss to be retrieved in each batch, before being passed individually to the blockj. For example to retrieve records in batches of 5000:

Customer.find_each(batch_size: 5000) do |customer|
NewsMailer.weekly(customer).deliverable_now
end
:finish 
Similar to the :start  option :finish allows you to configure the last ID of the sequence whenever the highest ID is not the one you need. This would be useful, for example,if you wnated to run a barch process using a subset of record based on :start and:finish
For example, to sned newsletter only to customers with  the primary key from 2000 up ot 10000:

Customer.find_each(start: 2000, finish:10000) do
|customer|
Newsmailer.weekly(customer).deliver_now
end
Another example would be if you wanted multiple workers handling the same processing queue You could have each worker handle 1000 records by setting the appropriate :start and :finish option on each worker.
:error_on_ignore
Ovverrides the application config if an error if aan error should be raised when an order is present in the relation.

find_in_batches 
the find_in_batches method is similar to find_each since both retrieve batches of record the difference is that find_in_batch ields batches to the block as an array of models, instead of individually The following example will yield to the supplied block an array of up to 1000 customers at a time, with the final block containig any remaining customers:

#Give add_customers an array of 1000 customers at a time
Customer.find_in_batches do |customers|
export.add_customers(customers)
end
find_in_batches works on model classes, as seenabove, and also on relations:
#give add_customers an array of 1000 recently active customers at at a time.
Customer.recently_active.find_in_batches do |customers|
export.add_customers(customers)
end
as long as they have no ordering since the method needs to force an order internally to iterate.
Option for find_in_batches
the find_in_batches mehod accepts the same option as find_each:
:batch_size
Just like for find_each, batch_size establishes how many rcords will be retrieved in each in each group. For example, retrieving batches of 2500 records can be specified as:

Customer.find_in_batches(batch_size: 2500) do
|customers|
export.add_customers(customers)
end

:start 
The start option allows you specifying the beginning ID from where records will be selected. As mentioned before By default records are fetching in ascending order of the primary key For example, For example to retrieve customers starting on ID: 5000 in batches of 2500 records the following code can be used :
Customer.find_in_batches(batch_size: 2500, start: 5000)
do |customers|
export.add_customers(customers)
end
:finish
The finish option allows specifying the ending ID of the records to be retrieved. The code below shows the case of retrieving customers in batches, up to the customer with ID : 7000
Customer.find_in_batches(finish: 7000) do |customers|
expert.add_customers(customers)
end
:error_on_ignore
The error_on_ignore option overrides the application config if an error should be raised when a specified order is presented in the relation.

Conditions
The where methods allows you to specify conditions to limit the records returned, representing the where part of the SQL statement Conditions can either be specified as a string. array or hash 
Pure string conditions
If you'd like to add conditions to your find, you could just specified them in there, just like Book.where(title= 'introduction to algorithms' ") This will find all books where the title fields values is 'Introducing to algorithms'.

Builders your own conditions as pure strings can leave you vulnerable to SQL injection exploits. For example Book.where("title Like '%3 {params[:title]}%'") Is not safe. see the next section for the preferred way to  handle conditions using an array.

Array conditions 
Now what if that title could vary say an argument from somewhere? The find would then taken the form : Book.where ("title = ?", params[:title])
to this code:
Book.where("title = #{params[:title]}")
because of argument safety. Putting the variable directly into the conditions string will pass the variable to the database as-is this means that it will be an unescaped variable directly from a user who may have malicious intent. If yu do this, you put your entire database they can do just because once a user finds out they can exploit your database they can do just about anything to it never ever put your argument directly insider the conditions string.
From more information on the dangers of SQL injections. see the ruby on rails Security Guide.

Placeholder conditions
Similar to the (?) replacement style of params, you can also specify keys in your conditions string along with a corresponding keys/values hash:
Book.where("created_at >= :start-date AND ctreated_at <= :end_date",
{start_date: params[:start_date], end_date:
params[:end_date]})

This makes for clear readability if you have a large number of variable condiitons.

Conditions That use LIKE
Although conditions arguments are automatically escaped to prevent SQL injection, SQL LIKE wildcards (i.e., % and _) are not escaped This may causes unexpected behaviour if an unsdanitized value is used in an argument. for example:
Book.where("title LIKE ?", params[:title] + "%")
In the above code, the intent is to match titles that start with a user-specified string.
However, any occurences of the % or _ in params[:title] will be treated as wildcards, leading to surprisingly query reesults, in some circumstances, this may also prevent the database from using an intendfed index, leading to a much slower query.

To avoid these problems, use sanitize SQL like to escape wildcard characters, in the relevant portion of the argument :
Book. where("title LIKE ?",
Book.sanitize_sql_like(params[:title]) + "%")
Hash Conditions
Active Record also allows yout o pass in hash conditions which can increase the readability of your conditions syntax. With hash conditions, you pass in a hash with keys of the fields you want qualified and the values of how you want to qualify them :
Only  equal, range, and subset checking are possible with hash conditions.

Equality conditions 
Book.where(out_of_print: true)
This will ggenerate SQL like this:
SELECT * FROM books WHERE (books.out_of_print = 1)
The field name can also be a string:
Book.where('out_of_print' => true)
In the case of a belongs_to relationship, an asociation key can be used to specify the model if an Active record object is used as the value. This method works with polumorphic relationship as well.
author =Author.first
Book.where(author:author)
Author.joins(:books).where(books: {author:author } )
Range conditions
Book.where(created_at : (time.now.midnight - 1.day)..Time.now.midnight)
This will find all books created yesterday by using a BETWEEN SQL statement:
SELECT* FROM books WHERE (books.created_at BETWEEN '2008-12-21 0000:00' AND '2008 - 12- 22 00:00:00')
This demonstrates a shorter syntax for the examples in Array Conditions
Subset Conditions 
If you want to find a shorter syntax for the example in Array Conditions 
Subset Conditions
If you want to find record using the IN expression you can pass an array to the conditions hash :

Customer.where(order_count: [1,3,5])
This covde will generate SQL like this:
SELECT * FROM cutomers WHERE (customers.orders_count IN (1,3,5))
NOT Conditions
NOT SQL queries can be built by where.not:
Customer.where.not(orders_count: [1,3,5])
In other words, this query can be generated by calling where with no argument, then immediately chain with not passsing where conditions. This will generate SQL like this:
SELECT * FROM customers.order_count NOT IN (1,3,5))
if a query has a hash condition will not-nil values on a nullable column, the records that have nil values on the nullable column won't be returned. For example:
Customer.create!(nullable_country:nil)
Customer.where.not(nullable_country: "UK")
=> []
#But
Customer.create!(nullable_country: "UK")
Cusotmer.where.not(nullable_country:nil)
=> [#<Customer id: 2, nullable_country: "UK">]
OR Conditions]OR conditions between two realations can be build by calling or on the first relation, and passing the second one as an argument.
Customer.where(last_name:
'Smith').or(Customer.where(ordfers_count: [1,3,5]))
SELECT* FROM customers WHERE (customers.last_name = 'Smith' OR customers.order_counts IN (1,3,5))
AND Conditions
AND conditions can be built by chasing where conditions.
Customer.where(last_name: 'Smith').where(orders_count: [1,3,5]))
SELECT *FROM cusotmers WHERE customers.last_name = 'Smith' AND customers.orders_count IN (1,3,5)
AND conditions for logical intersections between relations can be built by calling and on the first relations and passing the seconfd one as an argument.
Customer.where(id: [1,2]).and(Customer.where(id: [2,3]))
SELECT * FROM customers WHERE (customers.id IN (1,2)
AND customers.id IN (2,3)

ORDERING
To retrieve records from the databse ina specificx order, you can use the order method
For example, if you're getting aset of records and want to order them in ascending order by the create_at field in your table:

Book.ordfer(:created_at)
# OR 
Book.order("created_at")
You could specify ASC or DESC as well :
Book.order(created_at: :desc)
# OR 
Book.order(created_at: :asc)
# OR
Book.order("created_at DESC")
# OR 
Book.order("created_at ASC")

OR  ordering by multiple fields :
Book.order(title: :asc, created_at: :desc)
#OR 
Book.order(:title, created_at::desc)
#OR 
Book.order("title ASC, created_at DESC")
If you want to call order multiple times, subsequent orders will be appended to the first,
irb> Book.order("title ASC").ordfer("created_at DESC")
SELECT * FROM books ORDER BY title ASC, created_at DESC
In most database systems, on selecting fields with distimnct from a result set using methods like select, pluck and ids: the order mmethod will raise an ActiveRecord::StatementInvalid exception unless the fields used in order clasuse are included in the select list See the next section for selecting fields from the result set.

Selecting Specific Fields
By dfefaults, Model find selects all the fields from the result set using select * .

To select obly a subset of fields from the result set, you can specify the subset via the select method
For example, to select only isbn ans out_of_print columns:
Book.select(:isbn, :out_of_print)
#OR 
Book.select("isbn, out_of_print")
Rhe SQL query used by this find call will be somewhat like
SELECT isbn, out_of_print FROM books
Be careful because this also menas you're initializing objects with only the fields that you've slected. If you attempt to access a field that is not in the initialized record you'll receive 
Active model:: MissingAttributeError: missing attribute: <attribute>
Where <attribute> is the attribute you asked for. The id method will not raise the activeRecord::MissingAttrinuteError, so just be careful when working with associations because they need the id method to function properly.

If you would like to obly grab record per unique value in a cerain field, you can use distinct:
Customer.select(:last_name).distinct
This will generate SQL like:
SELECT DISTINCT last_name FROM customers
You can remove the uniqueness constraints:

#return unique last_names
query = Cusotmers.select(:last_name).distinct

#returns all last_names, even if there are duplicafted 
query.distinct(false)

LIMIT and OFFSET
To apply limit to the SQL fired by the Model.find you can specify the limit and offset methods on the relation.
You can limit to specify the number of records to be retrieved and use offset to specify the number of records to skip before starting to return the records For example

Customer.limit(5)
will return a maximum of 5 customers and bcause it specifies no offset it will return the first 5 in the table the sQL it executes loks like this:
SELECT *FROM customers LIMIT 5
Adding offset to that
Customer.limit(5).offset(30)
will return instead a maximum of 5 customers beginning with the 31st. The SQL liiks like
SELECT * FROM customers LIMIT 5 OFFSET 30 
GROUP 
To apply a group BY clause to the SQL fired by the finder, you can use the group method 
For Example, if you want to find a collection of the dates on which orders were created :

Order.select("created_at").group("created_at")
And this will give you a single Order object for each date where there are orders in the databse 
The SQL that would be executed would be something like this: 

SELECT created_at
FROM orders
GROUP BY created_at

Total of grouped items
To get the total of grouped items on a single query call count after the group 
irb> Order.group(:status).count
=> {"being_packed" => 7. "shipped" => 12}
The SQL that would be executed would be something like this:
SELECT COUNT (*) AS count_all status AS status 
FROM orders
GROUP BY  status

HAVING
SQL uses the having clause conditions on the GROUP BY fields. You can add the HAVING clause to the SQL fired by the Model.find by adding the having method to the find.
For Example

Order.select("created_at, sum(total) as total_price"),
group("created_at").having("sum(total) > ?", 200)

The SQL that would be executed would be something like this:
SELECT created_at as ordered_date, sum(total) as 
total_price
FROM orders
GROUP BY created_at
HAVING sum(total) > 200
This return the date and total price for each order object, grouped by the day they were ordered and where the total is more than $200
You would access the total_pricefor each order returned like this:
big_orders = Order.select("created_a, sum(total) as total_price")
.group("created_at")
.having("sum(total) > ?", 200)

big_order[0].total_price
#returns the total price for the first orderobject.



